A TagInfo class will be utilized to standardize the tag name, unit, description (if any), and data (time value quality triplet) 
usage across the usable classes (sensors, calculations, and controllers). 

The list of TagInfo instances across the entire system will be stored on the System instance. 

For sensor, all the info for the TagInfo are available at instantiation (i.e., when Sensor(...) is called). Thus,
we will put the TagInfo construction in model_post_init. The Unit, description, and name would be separate fields for
the sensor, since a single sensor always return a single (type of) measurement (some of these may be a vector instead of
a scalar, but they would share the same unit and description and tag name)

For calculation, all the info for the TagInfo are also available at instantiation time. However, we would make use of the
Annotated from typing to provide the necessary metadata (unit and description) for the output tags. 

For the input tags, we would also make use of Annotated to specify expected input units to the calculation. This
is because, for a calculation, the number of inputs and outputs, as well as the expected units for all of these,
are DEFINED at the time of Definition, NOT INSTANTIATION (i.e., when you define the subclass with class subcalc(Calculation):, 
not when you call subclac(...)). It is left to the user to convert the output's units to something else after the fact if 
desired (i.e., cant annotated output1 with units of m, but expect the calculation to return units of km). This 
is just to simplify the Annotation requirements. 

For controllers, the only new tags are the setpoints. As such, we will just grab the cv's TagInfo and 
modify slightly to represent the corresponding setpoint. We will NOT store the setpoint data directly
in the cv's TagInfo for now - instead, we will just add the postfix '.sp' or something and make
a new TagInfo.
    Even though it seems we need the cv's TagInfo, we don't. We will also make use of the Annotated's 
    additional metadata to specify what the expected unit of the CV and MV are, and make use of
    unit converters in the case that the controller's expected CV and/or MV are of a different 
    unit from the sensor/calculation's units. 
